from snakemake.utils import min_version

##### set minimum snakemake version #####
min_version("8.4.1")


configfile: "config/config.yaml"


include: "rules/common.smk"


rule all:
    input:
        ws_path("MR_instruments_best_snps_from_LB.txt"),
        ws_path("MR_instruments_best_snps_from_LB.vcf"),
        ws_path("MR_instruments_best_snps_from_LB_standard.vcf.gz"),
        ws_path("MR_instruments_LB_liftover.vcf"),
        ws_path("MR_instruments_LB_liftover.txt"),
        ws_path("mapped_LB.txt"),
        ws_path("annotated_LB.txt"),
        ws_path("heterogenous_LB.txt"),


rule select_best_SNP_from_LocusBreaker:
    input:
        lb=config.get("locus_breaker_filepath"),
        mapping=config.get("mapping_filepath"),
    output:
        MR=ws_path("MR_instruments_best_snps_from_LB.txt"),
        mapped=ws_path("mapped_LB.txt"),
        annotated=ws_path("annotated_LB.txt"),
    resources:
        runtimes=lambda wc, attempt: attempt * 20,
    params:
        NEF=config.get("params").get("nef"),
        sumstats_path=config.get("sum_stat_path"),
        path_to_targets_list=config.get("array_list_path"),
    conda:
        "envs/r_environment.yml"
    shell:
        """
         Rscript workflow/scripts/s01_best_snp_locus_breaker_for_MR.R \
            --input {input.lb} \
            --path {params.sumstats_path} \
            --array_path {params.path_to_targets_list} \
            --mapping {input.mapping} \
            --NEF {params.NEF} \
            --map_output {output.mapped} \
            --MR_output {output.MR} \
            --annot_output {output.annotated}
   """


rule vcf_file:
    input:
        lb=ws_path("MR_instruments_best_snps_from_LB.txt"),
    output:
        lb_vcf=ws_path("MR_instruments_best_snps_from_LB.vcf"),
    resources:
        runtimes=lambda wc, attempt: attempt * 20,
    conda:
        "envs/r_environment.yml"
    shell:
        """
            Rscript workflow/scripts/s06_prepareVCF_file.R \
             --input {input.lb} \
             --vcf_lb_output {output.lb_vcf}
   """


rule bcftools_liftover:
    input:
        lb_vcf=ws_path("MR_instruments_best_snps_from_LB.vcf"),
        hg37=config.get("hg37_fasta_file"),
        hg38=config.get("hg38_fasta_file"),
        chain_file=config.get("chain_file"),
    output:
        output_norm=ws_path("MR_instruments_best_snps_from_LB_standard.vcf.gz"),
        output_vcf=ws_path("MR_instruments_LB_liftover.vcf"),
        output_txt=ws_path("MR_instruments_LB_liftover.txt"),
    resources:
        runtimes=lambda wc, attempt: attempt * 20,
    conda:
        "envs/bcftools.yml"
    shell:
        """
        export BCFTOOLS_PLUGINS=/group/diangelantonio/software/liftOver_plugins/score_1.20-20240505 && \
        bgzip {input.lb_vcf} > {input.lb_vcf}.gz && \
        tabix -p vcf {input.lb_vcf}.gz && \
        bcftools norm -f {input.hg37} -c s -Oz -o {output.output_norm} {input.lb_vcf}.gz && \
        bcftools +liftover --no-version -Ou {output.output_norm} -- -s {input.hg37} -f {input.hg38} -c {input.chain_file} > {output.output_vcf} && \
        bcftools view {output.output_vcf} > {output.output_txt}
   """


# rule LB_liftover:
#    input:
#        lb_ivs=ws_path("MR_instruments_best_snps_from_LB.txt"),
#        mapping=config.get("mapping_filepath"),
#        chain_file=config.get("chain_file"),
#    output:
#        liftover_lb=ws_path("MR_instruments_best_snps_from_LB_liftover.txt")
#    conda:
#        "envs/r_environment.yml"
#    shell:
#        """
#         Rscript workflow/scripts/s05_liftover.R \
#            --input {input.lb_ivs} \
#            --chain_file {input.chain_file} \
#            --mapping {input.mapping} \
#            --liftover_lb_output {output.liftover_lb}
#   """

# rule gwas_liftover:
#    input:
#        input_file = ws_path("MR_instruments_best_snps_from_LB.txt"),
#    output:
#        liftover_output_file = ws_path("MR_instruments_best_snps_from_LB_liftover.txt"),
#        unmapped_output_file = ws_path("MR_instruments_best_snps_from_LB_unmapped.txt"),
#    resources:
#        runtimes=lambda wc, attempt: attempt * 20,
#    conda:
#        "envs/gwaslab_environment.yml",
#    params:
#        snpid="SNPID",
#        chrom="CHR",
#        pos="POS",
#        ea="EA",
#        nea="NEA",
#        neaf="EAF",
#        beta="BETA",
#        se="SE",
#        mlog10p="MLOG10P",
#        sep=",",
#        from_build="19",
#        to_build="38"
#    script:
#        "scripts/s04_liftover.py"


rule heterogenous_filter:
    input:
        ws_path("annotated_LB.txt"),
    output:
        ws_path("heterogenous_LB.txt"),
    resources:
        runtimes=lambda wc, attempt: attempt * 20,
    params:
        NEF=config.get("params").get("nef"),
        Isquare=config.get("params").get("Isquare"),
    conda:
        "envs/r_environment.yml"
    shell:
        """
         Rscript workflow/scripts/s03_heterogenous_filter.R \
            --input {input} \
            --NEF {params.NEF} \
            --het_output {output} \
            --Isquare_thresh {params.Isquare}
   """


# rule select_SNP_from_cojo:
#    input:
#        cojo=config.get("cojo_results"),
#        chain_file=config.get("chain_file"),
#        mapping=config.get("mapping_filepath"),
#    output:
#        unconditional=ws_path("MR_instruments_unconditional_analysis.txt"),
#        conditional=ws_path("MR_instruments_conditional_analysis.txt"),
#    resources:
#        runtimes=lambda wc, attempt: attempt * 120,
#    conda:
#        "envs/r_environment.yml"
#    shell:
#        """
#        Rscript workflow/scripts/s02_instruments_from_conditional_analysis.R \
#            --input {input.cojo} \
#            --mapping {input.mapping} \
#            --chain_file {input.chain_file} \
#            --conditional_output {output.conditional} \
#            --unconditional_output {output.unconditional}
#   """
